ЛАБОРАТОРНАЯ РАБОТА №4 (JAVA, ОБОБЩЕНИЯ, ИНТЕРФЕЙСЫ, ОБРАБОТКА КОЛЛЕКЦИЙ)

Автор: Белов Андрей
Группа: ИТ-9
Вариант: 2

----------------------------------------

#Задание 1 — Класс `Box<T>`
Описание:  
Создать обобщённый контейнер, который хранит ровно один объект типа `T`. Поддержать операции: положить, извлечь, посмотреть, проверить пустоту, человеко-понятный `toString()`.

Логика решения:
1. Объявлён класс `Box<T>` c приватным полем `value` — это инкапсуляция состояния, напрямую к нему не обращаются.
2. Метод `put(T v)` кладёт объект только если коробка пуста. Иначе — кидает `IllegalStateException` (защищаем инвариант «максимум один объект»).
3. Метод `get()` возвращает объект и обнуляет `value`, чтобы коробка стала пустой.
4. Метод `peek()` позволяет безопасно посмотреть значение без извлечения (нужно для аналитики: поиск максимума и т.п.).
5. Метод `isEmpty()` — быстрый способ узнать состояние; используется в интерфейсе и в проверках.
6. `toString()` выводит «Коробка пустая» либо «В коробке: X».

Почему так:  
- Generics позволяют применять один и тот же класс к разным типам (`Box<Integer>`, `Box<String>`...), не дублируя код.  
- Исключение в `put()` — прозрачный способ сообщить об ошибочном использовании (попытка перезаписи).  
- Разделение `peek()`/`get()` даёт «неразрушающий» доступ к данным.

Пример (ввод/вывод):

Положить: 5  →  В коробке: 5
Извлечь     →  Извлечено: 5; Коробка пустая


Граничные случаи: попытка положить во «внятую» коробку — ошибка; `peek()` на пустой — `null`.  
Сложность: все операции O(1).

----------------------------------------

#Задание 2 — Интерфейс `Сравнимое<T>` и класс `IntHolder`
Описание:  
Ввести интерфейс с единственным методом `сравнить(T obj): int`. Вернуть `<0 / 0 / >0` — меньше / равно / больше. Показать реализацию на числе.

Логика решения:
1. Интерфейс `Сравнимое<T>` — это контракт, который гарантирует наличие метода `сравнить` в реализациях.
2. Класс `IntHolder implements Сравнимое<Integer>` хранит `int value` и реализует сравнение через `Integer.compare(value, other)`.
3. В `main` пользователь задаёт базовое число и число для сравнения; по результату печатается `<`, `>` или `==`.

Почему так:  
- Интерфейс позволяет работать через ссылку на контракт, не завязываясь на конкретный класс.  
- Generics делают контракт универсальным — можно потом реализовать сравнение строк и т.п.

Пример (ввод/вывод):

База: 10; Сравнить с: 7  →  10 > 7
База: 10; Сравнить с: 10 →  ==


Сложность: O(1) на один вызов сравнения.

----------------------------------------

#Задание 3 — Поиск максимального (`MaxFinder`)
Описание:  
Реализовать метод, принимающий массив коробок с числами и возвращающий максимум в формате `double`.

Логика решения:
1. Сигнатура: `double findMax(Box<? extends Number>[] boxes)` — принимаем любой числовой тип в коробках (`Integer/Long/Double/...`).  
2. Проходим по массиву; пустые/`null` пропускаем.  
3. Берём значение через `peek()` (не очищая коробку), приводим к `double` (`Number.doubleValue()`), поддерживаем текущий максимум.  
4. Если данных не было — возвращаем `Double.NaN`.

Почему так:  
- `? extends Number` позволяет передавать смешанные числовые коробки.  
- `peek()` защищает содержимое от нежелательного опустошения.

Пример (ввод/вывод):

[5], [пусто], [12.3]  →  Максимум: 12.3


Граничные случаи: все коробки пустые → `NaN`.  
Сложность: O(n) по числу коробок, память O(1).

----------------------------------------

#Задание 4 — Универсальная функция `applyToEach` (map)
Описание:  
Сделать обобщённый метод, который применяет одну операцию ко всем элементам списка и возвращает новый список результатов.

Интерфейс операции:
java
interface Transformer<T,R> {
    R apply(T x);
}


Логика решения:
1. Метод `List<R> applyToEach(List<T> src, Transformer<T,R> f)` создаёт новый список.
2. Перебирает `src`, для каждого элемента вызывает `f.apply(item)` и складывает результат.
3. Исходный список не меняется.

Почему так:  
- Поведение (что именно делать) передаётся снаружи, метод остаётся универсальным.  
- Generics позволяют T и R быть разными типами.

Примеры (ввод/вывод):
- Строки → длины: `["qwerty","a","sun"]` → `[6,1,3]`  
- Числа → модуль: `[1,-3,7]` → `[1,3,7]`  
- Массивы → максимум: `[[1,5,3],[8]]` → `[5,8]`

Сложность: O(n) по элементам, память O(n) на результат.

----------------------------------------

#Задание 5 — Универсальный `filter` (predicate)
Описание:  
Сделать метод, который оставляет в списке только элементы, прошедшие проверку.

Интерфейс условия:
java
interface Tester<T> {
    boolean test(T x);
}


Логика решения:
1. Метод `List<T> filter(List<T> src, Tester<T> tester)` создаёт новый список.
2. Перебирает `src`, добавляет элемент в результат, если `tester.test(x)` вернул `true`.
3. Исходный список не меняется.

Примеры (ввод/вывод):
- Строки длиной ≥ 3: `["hi","cat","sun"]` → `["cat","sun"]`  
- Положительные числа: `[3,-1,7,0]` → `[3,7]`  
- Массивы без положительных: `[[1,-2],[-3,-5],[0,-9,4]]` → `[[-3,-5]]`

Сложность: O(n) по элементам, память O(k), где k — число прошедших элементов.

----------------------------------------

#Демонстрация в `main` и ввод с клавиатуры
Меню: разделы по заданиям 1–5. Для каждого предусмотрены шаги ввода (количество элементов, значения), защита от ошибок ввода (повтор запроса при неверных данных) и наглядный вывод результата.  
Важно: методы, работающие с коллекциями (`applyToEach`, `filter`) возвращают новые списки, не модифицируя исходные; `MaxFinder` читает значения через `peek()` и не опустошает коробки.

----------------------------------------

#Выводы
- Обобщения (generics) позволяют писать универсальные контейнеры и алгоритмы без копипасты.  
- Интерфейсы задают контракт поведения и позволяют передавать логику как объект (функциональные интерфейсы).  
- Отделение логики преобразования/проверки от «обхода коллекции» делает код расширяемым и понятным.

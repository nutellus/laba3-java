ЛАБОРАТОРНАЯ РАБОТА №4 (JAVA, ОБОБЩЕНИЯ, ИНТЕРФЕЙСЫ, ОБРАБОТКА КОЛЛЕКЦИЙ)

**Автор:** Белов Андрей
**Группа:** ИТ-9
**Вариант:** 2

------------------------------------------------------------
**Задание 1 — Класс Box<T>**

**Описание:**  
Создать обобщённый контейнер, который хранит ровно один объект типа T.  
Поддерживаются операции:
- положить объект,
- извлечь объект,
- посмотреть содержимое без извлечения,
- проверить пустоту,
- вывод состояния через toString().

**Логика решения:**  
1. Поле value хранит либо null, либо объект типа T.  
2. Метод isEmpty() проверяет состояние коробки.  
3. Метод put() кладёт объект только если коробка пустая. При попытке положить второй объект вызывается исключение — это не даёт нарушить правило «только один объект внутри».  
4. Метод get() возвращает значение и делает коробку пустой.  
5. Метод peek() позволяет посмотреть содержимое, не меняя состояние — это важно для задач анализа (например, поиска максимума).  
6. Метод toString() выводит состояние коробки в удобном виде.

**Пример:**  
Положили 5 → Коробка содержит 5  
Извлекли → Коробка пустая

------------------------------------------------------------
**Задание 2 — Интерфейс Сравнимое<T> и класс IntHolder**

**Описание:**  
Интерфейс задаёт обязательный метод сравнить(T obj), который должен возвращать:
< 0 — значение меньше  
= 0 — значения равны  
> 0 — значение больше

**Логика решения:**  
1. Интерфейс Сравнимое<T> выступает как «контракт» — любой реализующий его класс обязан иметь метод сравнить().  
2. Класс IntHolder хранит число и реализует метод сравнить с использованием Integer.compare.  
3. В main пользователь вводит число, программа сравнивает и выводит результат.

**Пример:**  
Храним: 10  
Сравнить с 7 → 10 > 7  
Сравнить с 10 → ==

------------------------------------------------------------
**Задание 3 — Поиск максимального значения (MaxFinder)**

**Описание:**  
Найти максимальное число среди набора коробок. Вернуть результат как double.

**Логика решения:**  
1. Используется тип Box<? extends Number> — это позволяет хранить в коробках разные числовые типы: Integer, Double, Long и др.  
2. Для каждой коробки значение берётся через peek(), чтобы не опустошать её.  
3. Значение приводится к double и сравнивается с текущим максимумом.  
4. Если все коробки пустые → возвращается NaN.

**Пример:**  
Коробки: [5], [пусто], [12.3] → максимум = 12.3

------------------------------------------------------------
**Задание 4 — Функция applyToEach**

**Описание:**  
Применить одну операцию ко всем элементам списка и вернуть новый список.

**Логика решения:**  
1. Интерфейс Transformer<T,R> описывает операцию преобразования (метод apply).  
2. Метод applyToEach проходит по списку, применяет операцию и складывает результаты в новый список.  
3. Исходный список **не изменяется**.

**Примеры:**  
Строки → длины: ["cat","sun"] → [3,3]  
Числа → модуль: [1,-3,7] → [1,3,7]  
Массивы → максимум: [[1,5,3],[8]] → [5,8]

------------------------------------------------------------
**Задание 5 — Фильтрация элементов (filter)**

**Описание:**  
Оставить в списке только элементы, удовлетворяющие условию.

**Логика решения:**  
1. Интерфейс Tester<T> имеет метод test(T), который возвращает true/false.  
2. Метод filter проходит по списку и добавляет в новый только те элементы, для которых test(x) вернул true.  
3. Исходный список не изменяется.

**Примеры:**  
Строки длиной ≥ 3 → ["hi","cat","sun"] → ["cat","sun"]  
Положительные числа → [3,-1,7,0] → [3,7]  
Массивы без положительных → [[1,-2],[-3,-5],[0,-9,4]] → [[-3,-5]]

------------------------------------------------------------
**Вывод:**  
В работе показано применение обобщённых классов, интерфейсов и универсальных методов обработки коллекций.  
Все решения построены так, что структура данных и логика обработки отделены — это делает программу понятной, гибкой и легко расширяемой.
